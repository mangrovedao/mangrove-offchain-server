// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider             = "postgresql"
  url                  = env("DATABASE_URL")
  referentialIntegrity = "prisma"
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["referentialIntegrity", "interactiveTransactions"]
}

generator typegraphql {
  provider        = "typegraphql-prisma"
  simpleResolvers = true
}

// data model

// Chains are created when?


model Chain {
  id   Int    @id
  name String

  transactions Transaction[]
  accounts     Account[]
  mangroves    Mangrove[]
  tokens       Token[]
}

// A transaction is create in all handlers, since every event is happing in a transcation.

model Transaction {
  id          String   @id @db.VarChar(255)
  chainId     Int      @default(80001)
  txHash      String   @db.VarChar(80)
  from        String   @db.VarChar(80) // msg.sender, the one who started the tx
  blockNumber Int
  blockHash   String   @db.VarChar(80)
  time        DateTime @db.Timestamp

  chain Chain @relation(fields: [chainId], references: [id])

// A transaction can hold multiple events, therefore everyting is arrays

  mangroveVersions      MangroveVersion[]
  takerApprovalVersions TakerApprovalVersion[]
  makerBalanceVersions  MakerBalanceVersion[]
  offerListVersions     OfferListVersion[]
  offerVersions         OfferVersion[]
  orders                Order[]
  orderSummaries        OrderSummary[]
}

// Tokens are created, when this event NewFungibleTokenStreamEvent, is found by proxima

model Token {
  id       String @id @db.VarChar(255)
  chainId  Int
  address  String @default("") @db.VarChar(80)
  symbol   String
  name     String
  decimals Int

  chain                   Chain       @relation(fields: [chainId], references: [id])
  offerListsWhereInbound  OfferList[] @relation("OfferListsByInboundToken") // Offerlists where the token is the inbound 
  offerListsWhereOutbound OfferList[] @relation("OfferListsByOutboundToken") // Offerlists where the token is the outbound 
}

// Is create when the event NewMgv is emitted. Proxima transforms this event to "MangroveCreated" 
model Mangrove {
  id      String @id @db.VarChar(255)
  chainId Int    @default(-1)
  address String @default("") @db.VarChar(80)

  chain          Chain           @relation(fields: [chainId], references: [id])
  offerLists     OfferList[]
  offers         Offer[]
  orders         Order[]
  makerBalances  MakerBalance[]
  takerApprovals TakerApproval[]

  // Events are not allowed to overwrite/delete data, as it might have to be restored on undo.
  // Instead, we create new versions which makes undo easy.
  currentVersionId String            @db.VarChar(255)
  mangroveVersions MangroveVersion[]
}

// Is created when one of these events is emitted:
// NewMgv - When a new Mangrove instance is deployed
// SetGovernance - When the governance is updated
// SetMonitor - When the monitor is update
// SetVault 
// SetUseOracle 
// SetNotify
// SetGasmax 
// SetGasprice
// Kill - When the Mangrove instance is killed (dead)

// Proxima converts all these events into "MangroveParamsEvents"
model MangroveVersion {
  id         String   @id @db.VarChar(255)
  mangroveId String   @db.VarChar(255)
  txId       String?  @db.VarChar(255)
  governance String?
  monitor    String?
  vault      String?
  useOracle  Boolean?
  notify     Boolean?
  gasmax     Int?
  gasprice   Int?
  dead       Boolean?

  tx Transaction? @relation(fields: [txId], references: [id])

  // The following fields are bookkeeping to support undo of events.
  versionNumber Int
  prevVersionId String? @db.VarChar(255) // This points to the older version that this version replaces, if any

  mangrove Mangrove @relation(fields: [mangroveId], references: [id])
}

// Is created when: every time an account is referenced, we check if it exists and create it if not

model Account {
  id      String @id @db.VarChar(255)
  chainId Int    @default(80001)
  address String @db.VarChar(80)

  chain Chain @relation(fields: [chainId], references: [id])

  ownedTakerApprovals   TakerApproval[] @relation("OwnerApprovals")
  spenderTakerApprovals TakerApproval[] @relation("SpenderApprovals")
  offers                Offer[]
  orders                Order[]
  makerBalances         MakerBalance[]
  takerOrderSummaries   OrderSummary[]

  strat Strat? // An account may be a strat contract
}

// What is strat??

model Strat {
  id String @id @db.VarChar(255)

  account Account @relation(fields: [id], references: [id])

  stratOrderSummaries OrderSummary[]
}

// This is created when the event "Approval" is emitted by Mangrove. Proxima renames it to TakerApprovalUpdated

model TakerApproval {
  id          String @id @db.VarChar(255)
  mangroveId  String @db.VarChar(255)
  offerListId String @db.VarChar(255)
  ownerId     String @db.VarChar(255)
  spenderId   String @db.VarChar(255)

  mangrove  Mangrove  @relation(fields: [mangroveId], references: [id])
  offerList OfferList @relation(fields: [offerListId], references: [id])
  owner     Account   @relation("OwnerApprovals", fields: [ownerId], references: [id])
  spender   Account   @relation("SpenderApprovals", fields: [spenderId], references: [id])

  // Events are not allowed to overwrite/delete data, as it might have to be restored on undo.
  // Instead, we create new versions which makes undo easy.
  currentVersionId      String                 @db.VarChar(255)
  takerApprovalVersions TakerApprovalVersion[]
}

// The actual approval value for a taker approval is stored here. Since the approval value can be updated, we use versions, to keep track of the value changes

model TakerApprovalVersion {
  id              String  @id @db.VarChar(255)
  takerApprovalId String  @db.VarChar(255)
  txId            String  @db.VarChar(255)
  parentOrderId   String? @db.VarChar(255)
  value           String  @db.VarChar(80)

  tx          Transaction @relation(fields: [txId], references: [id])
  parentOrder Order?      @relation(fields: [parentOrderId], references: [id])

  // The following fields are bookkeeping to support undo of events.
  versionNumber Int
  prevVersionId String? @db.VarChar(255) // This points to the older version that this version replaces, if any

  takerApproval TakerApproval @relation(fields: [takerApprovalId], references: [id])
}

// This event is created the first time a Debit and Credit is emitted by Mangrove. Proxima groups these 2 event into MakerBalanceUpdated

model MakerBalance {
  id         String @id @db.VarChar(255)
  mangroveId String @db.VarChar(100)
  makerId    String @db.VarChar(255)

  mangrove Mangrove @relation(fields: [mangroveId], references: [id])
  maker    Account  @relation(fields: [makerId], references: [id])

  // Events are not allowed to overwrite/delete data, as it might have to be restored on undo.
  // Instead, we create new versions which makes undo easy.
  currentVersionId     String                @db.VarChar(255)
  makerBalanceVersions MakerBalanceVersion[]
}

// We want to keep track of changes to the Maker Balance, because for this we create a new version everytime a maker balance is updated.

model MakerBalanceVersion {
  id             String @id @db.VarChar(255)
  makerBalanceId String @db.VarChar(255)
  txId           String @db.VarChar(255)
  balance        String @db.VarChar(80)

  tx Transaction @relation(fields: [txId], references: [id])

  // The following fields are bookkeeping to support undo of events.
  versionNumber Int
  prevVersionId String? @db.VarChar(255) // This points to the older version that this version replaces, if any

  makerBalance MakerBalance @relation(fields: [makerBalanceId], references: [id])
}

// This is create when any of these events are emitted by Mangrove
// SetActive
// SetFee
// SetGasbase
// SetDensity
// Proxima groups these into one event named OfferListParamsUpdated
// Why not call Market or Semibook?

model OfferList {
  id              String @id @db.VarChar(255)
  mangroveId      String @db.VarChar(255)
  inboundTokenId  String @db.VarChar(255)
  outboundTokenId String @db.VarChar(255)

  mangrove       Mangrove        @relation(fields: [mangroveId], references: [id])
  inboundToken   Token           @relation(name: "OfferListsByInboundToken", fields: [inboundTokenId], references: [id])
  outboundToken  Token           @relation(name: "OfferListsByOutboundToken", fields: [outboundTokenId], references: [id])
  offers         Offer[]
  takerApprovals TakerApproval[]
  orders         Order[]
  orderSummaries OrderSummary[]

  // Events are not allowed to overwrite/delete data, as it might have to be restored on undo.
  // Instead, we create new versions which makes undo easy.
  currentVersionId  String             @db.VarChar(255)
  offerListVersions OfferListVersion[]
}

// To keep track of the settings of the OfferList (Market/Semibook), we save a new version of it when an event change its settings 

model OfferListVersion {
  id          String   @id @db.VarChar(255)
  offerListId String   @db.VarChar(255)
  txId        String   @db.VarChar(255)
  active      Boolean?
  fee         String?  @db.VarChar(80)
  gasbase     Int?
  density     String?  @db.VarChar(80)

  tx Transaction @relation(fields: [txId], references: [id])

  // The following fields are bookkeeping to support undo of events.
  versionNumber Int
  prevVersionId String? @db.VarChar(255) // This points to the older version that this version replaces, if any

  offerList OfferList @relation(fields: [offerListId], references: [id])
}

// This is created when the Event OfferWrite is emitted by Mangrove. Proxima renames this to OfferWritten

model Offer {
  id               String  @id @db.VarChar(255)
  mangroveId       String  @db.VarChar(255)
  offerListId      String  @db.VarChar(255)
  makerId          String  @db.VarChar(255)
  // Events are not allowed to overwrite/delete data, as it might have to be restored on undo.
  // Instead, we create new versions or mark the offer as deleted, which makes undo easy.
  currentVersionId String  @db.VarChar(255)
  deleted          Boolean @default(false) // The offer has been deleted

  mangrove       Mangrove       @relation(fields: [mangroveId], references: [id])
  offerList      OfferList      @relation(fields: [offerListId], references: [id])
  maker          Account        @relation(fields: [makerId], references: [id])
  orderSummaries OrderSummary[]
  offerVersions  OfferVersion[]
}

// Both OfferWrite (Proxima name: OfferWritten) and OfferRetract (Proxima name: OfferRetracted) will update this.
// We can update an offer, because of this we keep track of the changes with Versions

model OfferVersion {
  id             String  @id @db.VarChar(255)
  offerId        String  @db.VarChar(255)
  txId           String  @db.VarChar(255)
  parentOrderId  String? @db.VarChar(255)
  prevOfferId    String? @db.VarChar(255)
  wants          String  @db.VarChar(80)
  wantsNumber    Float
  gives          String  @db.VarChar(80)
  givesNumber    Float
  takerPaysPrice Float?
  makerPaysPrice Float?
  gasprice       Int
  gasreq         Int
  live           Boolean
  deprovisioned  Boolean

  tx          Transaction @relation(fields: [txId], references: [id])
  parentOrder Order?      @relation(fields: [parentOrderId], references: [id])

  // The following fields are bookkeeping to support undo of events.
  versionNumber Int
  prevVersionId String? @db.VarChar(255) // This points to the older version that this version replaces, if any

  offer Offer @relation(fields: [offerId], references: [id])
}

// Proxima catches OrderStart and OrderComplete, and groups them as "OrderCompleted"

model Order {
  id              String  @id @db.VarChar(255)
  txId            String  @db.VarChar(255)
  parentOrderId   String? @db.VarChar(255)
  mangroveId      String  @db.VarChar(255)
  offerListId     String  @db.VarChar(255)
  takerId         String  @db.VarChar(255)
  takerGot        String  // Why not VarChar(255)??
  takerGotNumber  Float // Same as takerGot but as a Float
  takerGave       String
  takerGaveNumber Float // Same as takerGot but as a Float
  takerPaidPrice  Float?
  makerPaidPrice  Float?
  penalty         String // Why no PentalyNumber?? as with Got and Gave

  tx          Transaction @relation(fields: [txId], references: [id])
  parentOrder Order?      @relation("ParentOrders", fields: [parentOrderId], references: [id], onDelete: Restrict, onUpdate: Restrict)

  takenOffers                TakenOffer[]
  mangrove                   Mangrove               @relation(fields: [mangroveId], references: [id])
  offerList                  OfferList              @relation(fields: [offerListId], references: [id])
  taker                      Account                @relation(fields: [takerId], references: [id])
  childOrders                Order[]                @relation("ParentOrders")
  childTakerApprovalVersions TakerApprovalVersion[]
  childOfferVersions         OfferVersion[]
}

// This is create when Proxima emits the OrderCompleted event. An order can take many offers and there by create many "TakenOffer"'s

model TakenOffer {
  id               String  @id @db.VarChar(255)
  orderId          String  @db.VarChar(255)
  takerWants       String  @db.VarChar(80)
  takerWantsNumber Float
  takerGives       String  @db.VarChar(80)
  takerGivesNumber Float
  takerPaysPrice   Float?
  makerPaysPrice   Float?
  posthookFailed   Boolean
  failReason       String?

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

// strats

// This does not seem to be catched by Proxima yet. 
// It should be the event "OrderSummary" emitted by MangroveOrder.
// The OrderSummary event itself, does not contain the resting order Id, This is emitted by another event "NewOwnedOffer"
// Proxima will have to listen to both these events in order to fill this with correct data. 
// If the order was fully filled, then it would not post a resting order, and there would be no ID. 

model OrderSummary {
  id              String  @id @db.VarChar(255)
  txId            String  @db.VarChar(255)
  mangroveId      String  @db.VarChar(255)
  stratId         String  @db.VarChar(255)
  offerListId     String  @db.VarChar(255)
  takerId         String  @db.VarChar(255)
  selling         Boolean // Why do we need this? 
  takerGot        String
  takerGotNumber  Float
  takerGave       String
  takerGaveNumber Float
  price           Float
  penalty         String
  penaltyNumber   Float
  restingOrderId  String  @db.VarChar(255) // Maybe this should be optional? e.g., for a FoK order, there would be no resting order.

  tx           Transaction @relation(fields: [txId], references: [id])
  strat        Strat       @relation(fields: [stratId], references: [id])
  offerList    OfferList   @relation(fields: [offerListId], references: [id])
  taker        Account     @relation(fields: [takerId], references: [id])
  restingOrder Offer       @relation(fields: [restingOrderId], references: [id])
}

// store consumed streams state

// Is this a Proxima specific thing?

model Streams {
  id    String @id @db.VarChar(255)
  state String @db.VarChar(255)
}
